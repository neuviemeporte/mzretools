#!/usr/bin/env python3
import re
import textwrap
from output import error, debug
from util import Regex, squeeze, splitComment, sizeStr, cstrlen, parseNum, contains

class Datatype:
    '''types of encountered data items, not to be confused with data sizes (db/dw/dd)'''
    UNK = 0
    # TODO: change to "initialized" or something to that effect, scalars are also arrays which is stupid
    ARRAY = 1 # array of numeric values (even if one byte) 
    # TODO: is this needed?
    CSTR = 2  # a C-style string, kept as such 
    BSS = 3   # uninitialized value
    PTR = 4   # pointer to another value or segment
    NAME = { UNK: 'unknown', ARRAY: 'array', CSTR: 'cstring', BSS: 'bss', PTR: 'pointer' }
    CTYPE = { 'db': 'char', 'dw': 'int', 'dd': 'long' }
    TYPESIZE = { 'db': 1, 'dw': 2, 'dd': 4 }
    SIZETYPE = { 1: 'uint8', 2: 'int16', 4: 'int32' }

class Block:
    def __init__(self, begin, end):
        if (begin > end):
            raise ValueError('invalid block range')
        self.begin = begin
        self.end = end
    def __eq__(self, other):
        return self.begin == other.begin and self.end == other.end
    def __str__(self):
        return hex(self.begin) + "-" + hex(self.end)
    def colides(self, other):
        maxBegin = max(self.begin, other.begin)
        minEnd = min(self.end, other.end)
        return maxBegin <= minEnd

class Output:
    MAXLINE = 120
    def __init__(self, handle):
        self.handle = handle
        self.indent = ''
    def write(self, chars):
        if not self.handle:
            return
        if len(chars) > self.MAXLINE: # line too long?
            # split comment from instruction
            items = chars.split(';')
            instr = items[0]
            if instr and len(instr) > self.MAXLINE:
                error(f"Instruction string too long: {instr.rstrip()}")
            # write out comment before instruction
            # TODO: handle more than 2 items
            comment = items[1]
            chars = self.indent + instr + "\n"
            comment_wrap = textwrap.wrap(comment, self.MAXLINE)
            firstComment = True
            for c in comment_wrap:
                debug(f"writing comment line: '{c}'")
                if not firstComment: # replicate indent on subsequent lines if present
                    self.handle.write(self.indent)
                firstComment = False
                self.handle.write("; " + c + "\n")
        debug("writing " + chars.rstrip('\n'))
        if chars.isspace(): # save for next run
            self.indent = chars
        else:
            self.indent = ''
        self.handle.write(chars)

class Location:
    def __init__(self, segment, offset, contents, replace):
        self.segment = segment
        if isinstance(offset, str):
            self.offset = parseNum(offset)
        else:
            self.offset = offset
        self.contents = contents
        self.replace = replace
    def str(self):
        return f"Location {self.segment}:{self.offset}, contents: {self.contents}, replace: {self.replace}"
    def __repr__(self) -> str:
        return self.str()
    def match(self, segment, offset, instr):
        if segment != self.segment or offset != self.offset:
            return False
        if self.contents and not contains(instr, self.contents):
            return False
        return True
    def getReplace(self):
        if isinstance(self.replace, str):
            return [ self.replace ]
        return self.replace

class Extract:
    def __init__(self, segment, block, start = 0, end = 0, ported=True, filename=None):
        self.segment = segment
        self.block = block
        self.start = start
        self.end = end
        self.ported = ported
        self.filename = filename
        self.handle = None
    def str(self):
        return f"Extract {self.segment}:{self.block}, start: {self.start}, end: {self.end}, ported: {self.ported}, filename: {self.filename}"
    def __repr__(self) -> str:
        return self.str()
    def matchStart(self, tmpl):
        return (not self.start) or (tmpl.find(self.start) >= 0)
    def matchEnd(self, tmpl):
        return (not self.end) or (tmpl.find(self.end) >= 0)

class Routine:
    def __init__(self, name, type, start, comm):
        self.name = name
        self.type = type
        self.start = start
        self.comment = comm
        self.size = 0
        self.proto = None
    def close(self, end):
        self.end = end
        self.size = self.end - self.start
    def toString(self):
        if not self.name:
            return f"// bytes outside routine, potential module boundary at {hex(self.start)}"
        commstr = ''
        if self.comment:
            for c in self.comment:
                if c:
                    commstr += "// " + c + "\n"
        if self.proto: # an explicit prototype trumps an autogenerated one
            pstr = self.proto + ";"
        else:
            pstr = ''
            if self.type == 'far':
                pstr = f"int far {self.name}();"
            else:
                pstr = f"int {self.name}();"
        return commstr + pstr
    def setPrototype(self, proto):
        self.proto = proto

def ensureType(actual, required):
    if required == Datatype.UNK:
        error("Required unknown data type")
    if actual != required and actual != Datatype.UNK:
        debug(f"Found {Datatype.NAME[required]} data while previously encountered {Datatype.NAME[actual]} data, rejecting")
        return Datatype.UNK
    return required

def enforceType(actual, required):
    ret = ensureType(actual, required)
    if ret == Datatype.UNK:
        error(f"Invalid type: {Datatype.NAME[actual]}, required {Datatype.NAME[required]}")
    return ret

class Variable:
    def __init__(self, name, segment, offset, itemsz, comm, decl_str = None, decl_off = 0, itype = None):
        self.name = name
        self.segment = segment
        self.offset = offset
        self.itemsz = itemsz
        self.data = []
        # type (or rather category) of the data; whether it's initialized, bss, pointer...
        self.dtype = Datatype.UNK
        # actual datatype of the data in the common meaning
        self.itype = itype # item type 
        self.comment = comm
        self.decl = None
        self.dummy = False
        if decl_str:
            if decl_off == offset and name in decl_str:
                self.decl = decl_str
                debug(f"New var {name} accepted declaration: {decl_str}")
            else:
                debug(f"New var {name} rejected declaration {decl_str}, decl_off = {decl_off}, offset = {offset}")
    def dataLength(self):
        return len(self.data)
    def setDummy(self, arg):
        self.dummy = arg
    def setDecl(self, decl):
        self.decl = decl        
    def addData(self, data, dtype, itemsz, typename=None):
        dtype = ensureType(self.dtype, dtype)
        # if the type of the incoming data is different than this item's, or if the item size (byte/word/dword) does not agree, reject it
        if dtype == Datatype.UNK or itemsz != self.itemsz: 
            debug(f"Data rejected by variable {self.name}, type {Datatype.NAME[self.dtype]}, item size {self.itemsz} vs incoming {itemsz}")
            return False
        if typename:
            curtypename = "None"
            if self.itype:
                curtypename = self.itype.name
            if typename != curtypename:
                debug(f"Data rejected by variable {self.name}, incoming typename {typename} does not match current: {curtypename}")
                return False
        debug(f"Adding {sizeStr(len(data))} of data to variable {self.name}, previously {sizeStr(len(self.data))}")
        self.dtype = dtype
        self.data.extend(data)
        debug(f"Data accepted by variable {self.name}, type {Datatype.NAME[self.dtype]}, item size {sizeStr(self.itemsz)}, var size {sizeStr(self.size())}")
        return True
    def size(self):
        '''Number of bytes taken by this variable's data'''
        if self.dtype == Datatype.UNK:
            return -1
        elif self.itype:
            count = self.itype.getMemberCount()
            if self.dataLength() % count != 0:
                error(f"Data length ({self.dataLength()}) of variable {self.name} expected to be a multiple of member count: {count}")
            itemcount = self.dataLength() // count
            return self.itype.getSize() * itemcount
        elif self.dtype in [Datatype.ARRAY, Datatype.BSS, Datatype.PTR]:
            return len(self.data) * self.itemsz
        elif self.dtype == Datatype.CSTR:
            return sum([ cstrlen(str) for str in self.data ])
    def count(self):
        '''Number of elements in this variable (each might be more than 1 byte long)'''
        if self.itype:
            return self.dataLength() // self.itype.getMemberCount()
        return self.dataLength() // self.itemsz
    def declString(self):
        '''The variable declaration string that goes into the header file'''
        ret = ''
        if self.dtype ==Datatype.UNK:
            return ret
        ret = 'extern '
        if self.decl: # explicit declaration instead of autogenerated one
            ret += self.decl
            if not self.decl.endswith(';'):
                ret += ";"
            return ret
        if self.itype:
            ret += f"struct {self.itype.name} {self.name}"
        elif self.itemsz in Datatype.SIZETYPE:
            ret += f"{Datatype.SIZETYPE[self.itemsz]} {self.name}"
        else:
            error(f"Unable to deduce data type for {self.name}")
        if self.count() > 1 or self.dtype == Datatype.CSTR:
            ret += "[]"
        ret += ';'
        return ret
    def defString(self): 
        '''The variable definition string that goes into the source file'''
        ret = ''
        if self.dtype == Datatype.UNK:
            return ret
        if self.decl: # explicit declaration instead of autogenerated one
            ret += self.decl 
        else:
            ret += f"{Datatype.SIZETYPE[self.itemsz]} {self.name}"
        if self.count() > 1 or self.dtype == Datatype.CSTR:
            ret += "["
            if self.dtype == Datatype.BSS:
                ret += f"{hex(self.size() // self.itemsz)}"
            ret += "]"
        if self.dtype == Datatype.BSS:
            ret += ';'
            return ret
        ret += ' = '
        if self.count() > 1:
            ret += "{ "
        idx = 0
        for d in self.data:
            if idx != 0:
                ret += ", "
            if isinstance(d, int):
                ret += hex(d)
            elif len(d) == 1:
                ret += f"'{d}'"
            else:
                ret += d
            idx += 1
        if self.count() > 1:
            ret += " }"
        ret += ";"
        return ret

class Struct:
    def __init__(self, name, size):
        self.name = name
        self.size = size
        self.vars = []
    def getSize(self):
        return self.size
    def getMemberCount(self):
        return len(self.vars)
    def addVars(self, vars):
        oldsize = 0
        if self.vars:
            for v in self.vars:
                oldsize += v.size()
        debug(f"Adding {len(vars)} variables to structure {self.name}, existing vars' size = {oldsize}")
        varsize = 0
        for v in vars:
            varsize += v.size()
        totalsize = oldsize + varsize
        debug(f"Calculated new vars' size = {varsize}, total = {totalsize}")
        if totalsize > self.size:
            error(f"Total size of vars ({totalsize}) exceeds size ({self.size}) of structure {self.name}")
        self.vars.extend(vars)

class LstIterator:
    '''Iterate over listing lines and extract items for parsing'''
    lstline_re = re.compile(f'^({Regex.NAME}):' + r'([0-9a-fA-F]{4})(.*)')
    def __init__(self, file):
        self.file = file
        self.lineno = 0
    def nextItem(self):
        '''read next line from lst file and explode into components'''
        line = self.file.readline()
        # eof
        if not line:
            return None
        # get rid of tabs, squeeze, initial and final whitespace
        self.lineno += 1
        line = squeeze(line).strip()
        # extract segment, offset, instruction and comment if present
        if (match := self.lstline_re.match(line)) is None:
            error(f"Unexpected format on line {self.lineno}: '{line}'")
        segment = match.group(1)
        offset = int(match.group(2), 16)
        instr, comment = splitComment(match.group(3))
        instr = instr.strip()
        comment = comment.strip()
        debug(f"--- {self.lineno}: {segment}/{hex(offset)}/{instr}/{comment}/")
        return segment, offset, instr, comment
    def lineNumber(self):
        return self.lineno

class StructIterator(LstIterator):
    '''Iterate over lines of an .inc file until a structure ends'''
    ends_re = re.compile(f"^({Regex.NAME}){Regex.SPACES}ends")
    def __init__(self, file, name, size):
        super().__init__(file)
        self.structname = name
        self.structsize = size
        self.done = False
    def nextItem(self):
        if self.done: # already reached struct end
            return None
        line = self.file.readline()
        if not line: # eof before struct end?
            error(f"Unexpected EOF in {self.file.name} while looking for end of structure {self.structname}")
        self.lineno += 1
        line = squeeze(line).strip()
        if (match := self.ends_re.match(line)) is not None: # struct end
            structname = match.group(1)
            if structname != self.structname: # wrong struct end
                error(f"Found end of structure {structname} on line {self.lineno} of {self.file.name} while parsing structure {self.structname}")
            debug(f"=== Structure {self.structname} ends")
            self.done = True
            return None
        # struct data
        instr, comment = splitComment(line)
        instr.strip()
        comment = comment.strip()
        debug(f"--- {instr}/{comment}/")
        return None, None, instr, comment
