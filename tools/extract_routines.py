#!/usr/bin/env python3
# 
# This script processes an assembly file that was generated by the MS C compiler under DOS,
# extracts procedures from it and puts each one in a file of its own, so it can be included
# at a specific place inside the IDA-generated assembly listing of the target binary we are
# trying to reimplement in C.
#
import sys
import re
import os.path
from util import error, info, debug, start_proc, start_segment, end_proc, end_segment, symbol_islib, token_ignored, line_empty

curseg = ''
curproc = ''
lineno = 0

def process_token(token):
    # remove undserscores from tokens except ones starting with double underscore and known library symbols
    if token_ignored(token):
        return None
    if len(token) > 2 and token[0] == '_' and token[1] != '_':
        striptoken = token[1:]
        if not symbol_islib(striptoken):
            return striptoken
    return token

def process_line(line):
    # ignore empty lines and comments
    if not line or line_empty(line) or line[0] == ';':
        return ''
    tokens = line.split()
    # return segment start and end as is
    if start_segment(line) or end_segment(line):
        return line
    # dont put tab on procedure start and end, but process tokens
    elif start_proc(line) or end_proc(line):
        newline = ''
    # put tab before all other lines
    else:
        newline = '\t'
    i = 0
    for t in tokens:
        if i > 0:
            newline += ' '
        newtoken = process_token(t)
        # forbidden token
        if newtoken is None:
            return ''
        debug(f"\ttoken: '{newtoken}'")
        newline += newtoken
        i += 1
    return newline

def process_assembly(file, outdir):
    global lineno, curseg, curproc
    outfile = None
    for line in file:
        debug(f"line: {line.rstrip()}")
        lineno += 1
        p = process_line(line)
        debug(f"processed: {p}")
        if newseg := start_segment(p):
            if curseg:
                error(f"New segment '{newseg}' opened without closing previous one: '{curseg}", lineno)
            elif curproc:
                error(f"New segment '{newseg}' opened while procedure not closed: '{curproc}", lineno)
            curseg = newseg
            debug(f"Segment start: '{curseg}'")
        elif endseg := end_segment(p):
            if not curseg:
                error(f"Closing segment '{endseg}' without one being open", lineno)
            elif endseg != curseg:
                error(f"Closing segment '{endseg}' while current segment is '{curseg}'", lineno)
            debug(f"Segment ends: '{curseg}'")
            curseg = ''
            curproc = ''
        elif newproc := start_proc(p):
            if not curseg:
                error(f"New procedure '{newproc} 'without open segment", lineno)
            curproc = newproc
            outfilename = f"{outdir}/{newproc}.asm"
            info(f"Found routine: '{curproc}' -> {outfilename}")
            if outfile:
                outfile.close()
                outfile = None
            outfile = open(outfilename,"w")
        elif endproc := end_proc(p):
            if not curseg:
                error(f"Closing procedure '{endproc} 'without open segment", lineno)
            if not curproc:
                error(f"Closing procedure '{endproc}' without it being open", lineno)
            # ENDP does not mean procedure ended, there could be a function chunk belonging to the current procedure past it, 
            # so keep curproc value as it is
            debug(f"Routine end: '{curproc}'")
        if curproc and p and outfile:
            outfile.write(p + "\n")

def main(args):
    if len(args) != 3:
        error("Syntax: " + args[0] + " asmfile output_dir")

    asmfile = args[1]
    outdir = args[2]
    if not os.path.isfile(asmfile):
        error(f'Input file does not exist: {asmfile}')

    # create directory for output to put routine files into
    if not os.path.isdir(outdir):
        os.mkdir(outdir)
    
    # split input file into 
    with open(asmfile, encoding='cp850') as file:
        process_assembly(file, outdir)

if __name__ == '__main__':
    main(sys.argv)